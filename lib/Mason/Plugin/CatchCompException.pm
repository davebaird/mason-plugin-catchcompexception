package Mason::Plugin::CatchCompException;


# ABSTRACT: Allow components to catch their own exceptions

use Moose;
with 'Mason::Plugin';



1;

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package Mason::Plugin::CatchCompException::Request;
use Mason::PluginRole;

use Try::Tiny;

# catches .mc, .mi and .mp components (if they don't define their own handle() method)
around 'comp' => sub {
    my $orig = shift;
    my $self = shift;

    my $comp = $self->construct(@_);
    $comp->_setup_catch_comp_exception;

    try {
        $comp->main();
    }
    catch {
        my $err = $_;
        $comp->_do_catch_or_throw_component_exception($err);
    };
};

1;

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package Mason::Plugin::CatchCompException::Component;
use Mason::PluginRole;
use Try::Tiny;
use Scalar::Util qw(blessed);

# this seems to work, but I imagine it should be reset to 0 at the start of every request
our $_CatchCompException_buf_start_pos;

method _setup_catch_comp_exception () {
#    warn "In _setup_catch_comp_exception for " . $self->cmeta->path;
    my $buf_start = $Mason::Request::current_buffer;
#    warn "  -> setting buf_start_pos to " . length($$buf_start);
    $_CatchCompException_buf_start_pos = length($$buf_start);
    $self->{CatchCompException}->{ignore_error}   = 0;
    $self->{CatchCompException}->{catchers_count} = 0;
}

method _should_catch_component_exception ($error, $err_spec) {
    return 1 if ! blessed($error) && $error =~ qr~\Q$err_spec\E~;
    return 1 if blessed($error) && $error->isa('$err_spec');
    return 1 if $err_spec eq '*';
    return 0;
}

method _do_catch_or_throw_component_exception ($err) {
    $err->throw if blessed($err) && $err->isa('Mason::Exception');

    my $i = 0;
    while (my $catcher = "__catcher_" . $i++) {
        last unless $self->can($catcher);
        $self->$catcher($err);
        return if $self->{CatchCompException}->{ignore_error};
    }

    die $err;
}

# catches .mc components loaded as the page but blocks all further output
around 'handle' => sub {
    my $orig = shift;
    my $self = shift;

    $self->_setup_catch_comp_exception;

    try {
        $self->$orig();
    }
    catch {
        my $err = $_;
        $self->_do_catch_or_throw_component_exception($err);
    };
};

method discard () {
    $self->{CatchCompException}->{ignore_error} = 1;
    # throw away any content generated by this component before the exception
    my $buf = $Mason::Request::current_buffer;
    my $discard = substr $$buf, $_CatchCompException_buf_start_pos;
    my $keep    = substr $$buf, 0, $_CatchCompException_buf_start_pos;
#    warn "Buffer length: " . length($$buf);
#    warn "Start pos: " . $self->{CatchCompException}->{buf_start_pos};
#    warn "Discard length: " . length($discard);
#    warn "Keep length: " . length($keep);
    $$buf = $keep;
    return $discard;
}

method retain () {
     $self->{CatchCompException}->{ignore_error} = 1;
}


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package Mason::Plugin::CatchCompException::Compilation;
use Mason::PluginRole;
use Regexp::Common qw /delimited/;

around 'named_block_types' => sub {
    my $orig = shift;
    my $self = shift;
    my $types = $self->$orig;
    push @$types, 'catch';
    return $types;
};

method _handle_catch_block ($contents, $err_spec1, $err_spec2) {
    my $err_spec = $err_spec1 . $err_spec2;

    $self->_throw_syntax_error("Error spec must be ' or \" or [] quoted ($err_spec)")
      if $err_spec !~ $RE{delimited}{-delim=>q{'"}};

    $err_spec =~ s/^['"\[]//;
    $err_spec =~ s/['"\]]$//;

    my $code = "% return unless \$self->_should_catch_component_exception(\$error, q[$err_spec]);\n$contents";

    my $name = "__catcher_" . $self->{CatchCompException}->{catchers_count}++;
    $self->_handle_method_block( $code, $name, '($error)' );
}

1;



=head1 SYNOPSIS

    Type                         How caught      Comment
    .mc, page                    handle()        Blocks further output
    .mc, comp                    comp()          OK
    .mi                          comp()          OK
    .mp with handle(), page
    .mp with handle(), comp
    .mp, bare, page
    .mp, bare, comp              comp()          OK


    <%catch "Error message">
        # do something (error message is in $error)

        #then:
        $.discard();
        # or
        $.retain();
        # or

        # neither - error rethrown
    </%catch>

    <%catch "My::Exception::Class">
        #
        if ($error->message eq 'Blah') {
            $.discard();
            # etc
    </%catch>
=cut
